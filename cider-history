;; -*- coding: utf-8-unix -*-
;; Automatically written history of CIDER REPL session
;; Edit at your own risk

("(ns shadow.user)" "(pull)" "(def ssb (ssbClient sbot_callback))" "(ns ssb-cljent)" "answer" "(reduce #(> 1000 (:x %)) answer)" "(map parse-claim input-test)" "(def input-test [\"#1 @ 1,3: 400x400\", \"#2 @ 3,1: 4x4\", \"#3 @ 5,5: 2x2\", \"#3 @ 3,3: 2x2\"])" "(count answer)" "(def answer (question-3-answer))" "(count answer)" "(def answer (question-3-answer))" "(set (for [[a b] (combo/combinations (map parse-claim input-test) 2)] (get-overlap a b)))" "(def input-test [\"#1 @ 1,3: 4x4\", \"#2 @ 3,1: 4x4\", \"#3 @ 5,5: 2x2\", \"#3 @ 3,3: 2x2\"])" "(set (for [[a b] (combo/combinations (map parse-claim input-test) 2)] (get-overlap a b)))" "(def input-test [\"#1 @ 1,3: 4x4\", \"#2 @ 3,1: 4x4\", \"#3 @ 5,5: 2x2\"])" "(def input-test (\"#1 @ 1,3: 4x4\", \"#2 @ 3,1: 4x4\", \"#3 @ 5,5: 2x2\"))" "(count (apply set-of-squares (parse-claim \"#123 @ 3,2: 5x4\")))" "(apply set-of-squares (parse-claim \"#123 @ 3,2: 5x4\"))" "(set-of-squares (parse-claim \"#123 @ 3,2: 5x4\"))" "(count (question-3-answer))" "(frequencies (map type answer))" "(contains? answer nil)" "(count answer)" "(def answer (question-3-answer))" "(question-3-answer)" "(get-overlap [1 1 1 1] [2 2 1 1])" "(overlap? [1 1 1 1] [2 2 1 1])" "(get-overlap [1 1 1 1] [2 2 1 1])" "(overlap? [1 1 1 1] [2 2 1 1])" "(get-overlap [1 1 5 5] [1 1 1 4])" "(get-overlap [1 1 5 5] [1 1 1 1])" "(* 17 23)" "(parse-claim (first input3))" "(count (apply set-of-squares (parse-claim (first input3))))" "*1" "*2" "(apply set-of-squares (parse-claim (first input3)))" "(set-of-squares (parse-claim (first input3)))" "(parse-claim (first input3))" "(doseq [claim input3] (prn claim))" "(doseq [claim input3] (parse-claim claim))" "(count (set-of-squares 1 3 4 4))" "(set-of-squares 1 3 4 4)" "(count (get-overlap [1 1 5 5] [3 3 5 5]))" "(question-3-answer)" "(get-overlap [1 1 5 5] [3 3 5 5])" "(overlap? [1 1 5 5] [3 3 5 5])" "(within? 3 1 6)" "(overlap? [1 1 5 5] [3 3 5 5])" "(get-overlap [1 1 5 5] [3 3 5 5])" "(question-3-answer)" "(count (set [a b]))" "(set [a b])" "(set (a b))" "(set a b)" "(= a b)" "(def b (square. 1 1))" "(def a (square. 1 1))" "(square. 1 1)" "(square 1 1)" "(def a (square 1 1))" "(ns adventofcode.core)" "(count (clojure.set/intersection (set (range 1 16)) (set (range 5 15))))" "(count (clojure.set/intersection (set (range 1 10)) (set (range 5 15))))" "(count (clojur.set/intersection (set (range 1 10)) (set (range 5 15))))" "(clojure.set/intersection (set (range 1 10)) (set (range 5 7)))" "(clojure.set/intersection (range 1 10) (range 5 7))" "(for [item input3] (apply lay-claim (parse-claim item)))" "(check-bit 1 1)" "(check-bit 1 2)" "(add-used 1 1)" "@occupied" "(swap! occupied conj (str 1 \"-\" 2))" "@occupied" "(parse-claim (first input3))" "@occupied" "(ns adventofcode.core)" "(if (check-bit 276 438) \"true\" \"false\")" "(count @occupied)" "(check-bit 276 438)" "(count occupied)" "occupied" "(check-overlap)" "(type check-overlap)" "occupied" "(conj occupied \"1-1\")" "occupied" "(def occupied (conj occupied \"1-3\"))" "occupied" "(def occupied (conj occupied \"1-2\"))" "(conj occupied \"1-1\")" "(type occupied)" "occupied" "(println occupied)" "(rest (re-find claim-regex (first input3)))" "(map #(String. %) (rest (re-find claim-regex (first input3))))" "(map #(String. %) (rest (refind claim-regex (first input3))))" "(map String. (rest (refind claim-regex (first input3))))" "occupied" "(ns adventofcode.core)" "occupied" "(aget test 1)" "(aset-boolean test 1 true)" "(aget test 1)" "test" "(def test (boolean-array 100))" "(* 1000 1000)" "(check-overlap)" "(for [item input3] (lay-claim (parse-claim item)))" "(def used (atom {}))" "(parse-claim (first input3))" "(parse-claim (first iput3))" "(map #(lay-claim (parse-claim %)) input3)" "(frequencies (vals used))" "used" "(check-overlap)" "(keyword \":x1y1\")" "(str \":x\" 1)" "(key (str \"x\" 1 \"y\" 1))" "(key \"x\" 1 \"y\" 1)" "(swap! used updat-in [:x1y1] inc)" "(def used (atom {}))" "(swap! used update-in [:x1y1] inc)" "(def used {})" "(def used (assoc used :x0y0 1))" "(assoc used :x0y0 1)" "(assoc used :0,0 1)" "(assoc used (0 0) 1)" "(assoc used inc)" "(def used {})" "(ns adventofcode.core)" "(set-square 1 1)" "(frequencies (flatten @state))" "(frequencies (flatten @a))" "(frequencies (flatten @s))" "(frequencies @a)" "(count (true true false))" "(reduce #(> 2 %) (flatten @a))" "(reduce #(> 2 %) (flatten @2))" "(flatten @a)" "(reduce #(> 2 %) (flatten @state))" "(swap! a update-in [1 1] inc)" "a" "(def a (atom (blank 10 10)))" "(blank 10 10)" "(blnk 10 10)" "(ns adventofcode.core)" "(ns)" "(conj (repeat 10 \". \") \"/n\")" "(repeat 10 (apply str (conj (repeat 10 \". \") \"/n\")))" "(apply str (repeat 10 \". \"))" "(apply str (repeat 10 \".\"))" "(repeat 10 \".\")" "(str \".\" \".\")" "(str (repeat 10 \".\"))" "@state" " (ns adventofcode.core)" "(ns adventofcode.core)" "@state" "(int \"1\")" "(re-find claim-regex (first input3))" "input3" "(ns adventofcode.core)" "input3" "input 3" "(blank 10 10)" "@fabric" "fabric" "(prn @fabric)" "@fabric" "(prn fabric)" "(prn blank)" "(integer? \"no\")" "(pos? \"no\")" "(primes 1)" "(-main)" "(ns prime-times-table.core)" "(ns)" "(-main)" "(-main 9)" "(number? (read-string \"9\"))" "(pos-int? (read-string \"9\"))" "(pos-int? 1)" "(pos-int? (read-string \"9\"))" "(read-string \"9\")" "(stop)" "
(ns overtone-clj-toys.binaural
  (:use [overtone.live]))

;;
;; Binaural Beat Synthesis:
;; Generates binaural beats given the provided carrier and desired
;; frequency. Brown noise is used to soften the background and
;; block out outside noise.

;; freq    effect
;;   < 4   Delta, Sleep
;; 3 - 7   Theta, relaxation, meditation
;; 7 - 13  Alpha, Relaxation while Awake
;;
(defsynth bbeat [amp 0.3
                 carrier 440
                 freq 4.5]
  (let [freq-a carrier
        freq-b (+ carrier freq)
        left (* 0.8 (sin-osc freq-a))
        right (* 0.8 (sin-osc freq-b))]
    (out 0 (* amp left))
    (out 1 (* amp right))))

(defcgen snare-drum
  \"basic synthesised snare drum\"
  [bpm {:default 120 :doc \"tempo of snare in beats per minute\"}]
  (:ar
   (let [snare (* 3 (pink-noise [1 1]) (apply + (* (decay (impulse (/ bpm 240) 0.5) [0.4 2]) [1 0.05])))
         snare (+ snare (bpf (* 4 snare) 2000))]
     (clip2 snare 1))))

(defcgen kick-drum
  \"basic synthesised kick drum\"
  [bpm {:default 120 :doc \"tempo of kick in beats per minute\"}
   pattern {:default [1 0] :doc \"sequence pattern of beats\"}]
  (:ar
   (let [kickenv (decay (t2a (demand (impulse:kr (/ bpm 30)) 0 (dseq pattern INF))) 0.7)
         kick (* (* kickenv 7) (sin-osc (+ 40 (* kickenv kickenv kickenv 200))))]
     (clip2 kick 1))))

(definst drums [bpm 120]                                             
(let [kick (kick-drum bpm :pattern [1 0 0 0 0 0 1 0 1 0 0 1 0 0 0 0])
       snare (snare-drum bpm)]                                       
   (clip2 (+ kick snare) 1)))

;;(bbeat 0.2 440 3)
;;(stop)" "(demo (sin-osc 200))" "(demo (kick))" "(demo (sin-osc))" "(demo 7 (lpf (mix (saw [50 (line 100 1600 5) 101 100.5]))
                   (lin-lin (lf-tri (line 2 20 5)) -1 1 400 4000)))" "(demo (sin-osc))" "(use 'overtone.live)" "(demo (sin-osc))" "(< \"one\" \"three\")" "(apply str (map #(format \" aka %s\" alia)))" "(apply str (map #(str \"aka \" %) alia))" "(apply str (map #(str \"aka \" %s) alia))" "(apply st (map #(str \"aka \" %s) alia))" "(reduce #(str \"aka \" %) alia)" "(join \", \" alia)" "(apply str alia)" "(map str alia)" "(str alia)" "(map #(str \" aka \" %s) alia)" "(apply #(str %) alia)" "(apply str alia)" "alia" "(apply #(str \"aka\" %) alia)" "(apply str #(format \" aka %s\" %) alia)" "(apply #(format \" aka %s\" %) alia)" "(format \"aka %s\" \"1\")" "(apply #(format \" aka %s\" %) alia)" "(def alia [\"1\" \"2\" \"3\"])" "(cons (last coll) '())" "(cons coll '())" "(cons col '())" "(first [1])" "(last [1])" "(cons (last coll))" "(cons last coll)" "(last coll)" "(def coll [1 2 3 4 5])" "(subs \"Hello World\" \" \" 2)" "(str \"Cool\" \"right?\")" "(cell)" "(print-multiplication-table! [1 2 3 4 5 6 7 8 9 10])" "(macroexpand (test-print-stdout [(print-multiplication-table! [1]) \" 1\\n 1 1\"]))" "(slurp \"/tmp/lein-trampoline-HwG8Zg65Ce4KV\")" "(print-multiplication-table! [1])" "(print-multiplication-table! 1)" "(cell 0 1)" "(cell 1 1)" "(is (= (primes 0) ()))                            " "(primes 10)" "(prime 10)" "(run-tests)" "(run-all-tests)" "(primes 1)" "(primes 0)" "(prime 10)" "(prime 1)" "(prime 0)" "(primes 10)" "(-main 1000)" "(-main 15)" "(-main 2)" "(-main 1)" "(-main 20)" "(-main 10)" "(-main 20)" "(-main)" "(apply str b)" "(str b)" "(-main)" "(apply print b)" "(print b)" "b" "(def b '(1 2 3 4 5))" "(def b (1 2 3 4 5))" "a" "(-main)" "(cell 5 5)" "(-main)" "(apply str cell 5 a)" "(apply str a)" "(str a)" "(apply print a)" "a" "(pprint a)" "(print-table a)" "(use 'clojure.pprint)" "(print-table a)" "a" "(-main)" "(cell 5 \"s\")" "(cell 5 12345)" "(cell 1 25)" "(cell 7 5)" "(-main)" "(cell 5 \" \")" "(format \"%7s\" \".\")" "(cell 5 \" \")" "(number? \" \")" "(cell 5 \" \")" "(create-row (cell 5 3) a )" "(create-row (cell 5 3) (apply cell 5 a))" "(create-row \"b\" [1 2 3 4])" "(apply cell 5 a)" "(/ 123 10)" "(mod 10 100)" "(mod 100 10)" "(apply #(cell 5 %) a)" "(def a [1 2 3 4])" "(iterate inc 2)" "(time (take 10000 (sieve (iterate inc 2))) )" "(time (take 1000 (sieve (iterate inc 2))))" "(time (take 100 (sieve (iterate inc 2))))" "(time (take 10 (sieve (iterate inc 2))))" "(time (take 10 sieve (iterate inc 2)))")